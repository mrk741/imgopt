<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover • Bulk Image Optimizer</title>
  <link rel="icon" href="data:;base64,=" />
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0b0d12">
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    a{color:#4b82ff;text-decoration:none}
    header{padding:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;background:#0f1320;border-bottom:1px solid #1e2332}
    header h1{margin:0;font-size:20px;font-weight:700}
    nav a{margin-left:16px;font-size:14px;color:var(--muted)}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px;margin-top:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    #qualityVal{font-weight:600;margin-left:6px;color:#4b82ff}
    .footer{margin-top:12px;color:#7c8798;font-size:12px;text-align:center}
    .tag{font-size:11px;background:#0d1220;border:1px solid #1d2740;color:#a6b0c0;padding:2px 6px;border-radius:999px}
    .hidden{display:none}
  </style>
</head>
<body>
  <header>
    <h1>Background Remover + Bulk Optimizer</h1>
    <nav>
      <a href="about.html">About</a>
      <a href="help.html">Help</a>
      <button id="installBtn" class="btn" style="margin-left:12px;display:none">Install App</button>
    </nav>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop">
          <p><strong>Drop images here</strong> or click to browse</p>
          <input id="file" type="file" accept="image/*" multiple class="hidden" />
          <p class="muted">PNG, JPG, WebP, AVIF • processed locally</p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <label>Max width (px)
            <input type="number" id="maxWidth" min="64" step="16" value="1600" />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" min="64" step="16" value="1600" />
          </label>
          <label>Output format
            <select id="format">
              <option value="webp">WebP</option>
              <option value="avif">AVIF</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="82" />
            <span id="qualityVal">82%</span>
          </label>
          <label>Background removal
            <select id="bgMode">
              <option value="people" selected>People (on-device)</option>
              <option value="none">Disabled</option>
            </select>
          </label>
          <label>Canvas color (if not transparent)
            <input type="color" id="canvasColor" value="#000000" />
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process Images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <button class="btn" id="clearBtn">Clear Queue</button>
        </div>
        <p class="muted">All work happens in your browser. Nothing is uploaded.</p>

        <div class="footer">
          <span class="tag">MediaPipe</span>
          <span class="tag">Canvas encoders</span>
          <span class="tag">JSZip</span>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar" style="margin:10px 0 14px"><i id="prog"></i></div>
        <div class="thumbs" id="thumbs"></div>
      </div>
    </div>
  </div>

  <!-- Dependencies (UMD, no modules) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

  <script>
    // ---------- Elements ----------
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const clearBtn = $('clearBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const qualityVal = $('qualityVal');
    const bgMode = $('bgMode');
    const canvasColor = $('canvasColor');

    let files = [];
    let zip = null;

    // ---------- Helpers ----------
    quality.addEventListener('input', () => { qualityVal.textContent = quality.value + '%'; });

    function supportsType(mime) {
      try {
        const c = document.createElement('canvas'); c.width = c.height = 2;
        return new Promise((res) => c.toBlob((b) => res(!!b), mime, 0.8));
      } catch { return Promise.resolve(false); }
    }

    function accept(items) {
      const imgs = Array.from(items).filter(f => /^image\//.test(f.type) || /\.(png|jpe?g|webp|avif|heic|heif|gif|bmp)$/i.test(f.name));
      if (!imgs.length) { alert('No images detected.'); return; }
      files = files.concat(imgs);
      countEl.textContent = files.length + ' items';
      runBtn.disabled = files.length === 0;
      renderQueue();
    }

    fileInput.addEventListener('change', (e) => accept(e.target.files));
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
      drop.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); });
    });
    drop.addEventListener('dragenter', () => drop.style.borderColor = '#2b6ef3');
    drop.addEventListener('dragleave', () => drop.style.borderColor = '#33415c');
    drop.addEventListener('drop', (e) => { drop.style.borderColor = '#33415c'; accept(e.dataTransfer.files); });
    drop.addEventListener('click', () => fileInput.click());

    clearBtn.addEventListener('click', () => {
      files = [];
      thumbs.innerHTML = '';
      countEl.textContent = '0 items';
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
    });

    function renderQueue() {
      let html = '';
      for (let i = 0; i < files.length; i++) {
        html += "<div class='thumb'>" +
          "<img id='img-" + i + "' alt='preview' />" +
          "<div class='muted'>" + files[i].name + "</div>" +
          "<div class='muted' id='status-" + i + "'>Queued</div>" +
          "</div>";
      }
      thumbs.innerHTML = html;
      files.forEach((f, i) => {
        const reader = new FileReader();
        reader.onload = () => { const img = $('img-' + i); if (img) img.src = reader.result; };
        reader.readAsDataURL(f);
      });
    }

    // ---------- Background removal (people) ----------
    let selfieSeg = null;
    (async function initSeg() {
      if (window.SelfieSegmentation) {
        selfieSeg = new SelfieSegmentation({ locateFile: (f) => "https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/" + f });
        selfieSeg.setOptions({ modelSelection: 1 });
        if (typeof selfieSeg.initialize === 'function') {
          try { await selfieSeg.initialize(); } catch(e) { console.warn('Segmentation init', e); }
        }
      }
    })();

    function removeBgCanvas(baseCanvas) {
      return new Promise((resolve) => {
        if (!selfieSeg) return resolve(baseCanvas);
        const w = baseCanvas.width, h = baseCanvas.height;
        const img = new Image();
        img.onload = function () {
          selfieSeg.onResults(function(res){
            try {
              const maskC = document.createElement('canvas'); maskC.width = w; maskC.height = h;
              const mc = maskC.getContext('2d');
              mc.drawImage(res.segmentationMask, 0, 0, w, h);
              const mask = mc.getImageData(0,0,w,h);

              const ctx = baseCanvas.getContext('2d');
              const imgData = ctx.getImageData(0,0,w,h);
              const p = imgData.data, m = mask.data; const t = 128;
              for (let i=0;i<p.length;i+=4) { p[i+3] = (m[i] > t) ? 255 : 0; }
              ctx.putImageData(imgData,0,0);
              resolve(baseCanvas);
            } catch (err) {
              console.warn('Matte failed', err);
              resolve(baseCanvas);
            }
          });
          selfieSeg.send({ image: img });
        };
        img.onerror = function(){ resolve(baseCanvas); };
        img.src = baseCanvas.toDataURL('image/png');
      });
    }

    function fitSize(w, h, maxW, maxH) {
      const r = Math.min(maxW / w, maxH / h, 1);
      return { w: Math.max(1, Math.round(w * r)), h: Math.max(1, Math.round(h * r)) };
    }

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = function(){ URL.revokeObjectURL(url); resolve(img); };
        img.onerror = function(e){ URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    function encodeCanvas(canvas, type, q) {
      var mime = (type === 'jpeg') ? 'image/jpeg' :
                 (type === 'png')  ? 'image/png'  :
                 (type === 'avif') ? 'image/avif' : 'image/webp';
      return new Promise(function(resolve){ canvas.toBlob(function(b){ resolve(b); }, mime, q); });
    }

    document.getElementById('runBtn').addEventListener('click', async function(){
      if (!files.length) return;
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      zip = new JSZip();

      const maxW = parseInt(maxWidth.value, 10);
      const maxH = parseInt(maxHeight.value, 10);
      let outFmt = formatSel.value;
      const q01 = parseInt(quality.value, 10) / 100;
      const doBg = (bgMode.value === 'people');

      // If chosen format unsupported, fall back to PNG
      var mimeWanted = (outFmt==='jpeg')?'image/jpeg':(outFmt==='png')?'image/png':(outFmt==='avif')?'image/avif':'image/webp';
      var supported = await supportsType(mimeWanted);
      if (!supported) outFmt = 'png';

      let done = 0;
      for (let i=0;i<files.length;i++){
        const f = files[i];
        const st = $('status-'+i);
        try {
          st.textContent = 'Reading…';
          const img = await loadImage(f);

          // Work at source resolution for matte, then resize
          const work = document.createElement('canvas');
          work.width = img.naturalWidth || img.width;
          work.height = img.naturalHeight || img.height;
          const wc = work.getContext('2d');
          wc.imageSmoothingQuality = 'high';
          wc.drawImage(img, 0, 0);

          if (doBg) {
            st.textContent = 'Removing background…';
            await removeBgCanvas(work);
          }

          const size = fitSize(work.width, work.height, maxW, maxH);
          const out = document.createElement('canvas');
          out.width = size.w; out.height = size.h;
          const oc = out.getContext('2d');
          oc.imageSmoothingQuality = 'high';

          // Fill if target is opaque (jpeg) or a color requested
          const needsOpaque = (outFmt === 'jpeg');
          if (needsOpaque) {
            oc.fillStyle = canvasColor.value;
            oc.fillRect(0,0,size.w,size.h);
          }

          oc.drawImage(work, 0, 0, size.w, size.h);

          st.textContent = 'Encoding…';
          const blob = await encodeCanvas(out, outFmt, q01);

          // Preserve original name but swap extension only if mime suggests a better one
          let ext = outFmt;
          if (blob && blob.type) {
            if (blob.type.indexOf('jpeg') >= 0) ext = 'jpg';
            else if (blob.type.indexOf('png') >= 0) ext = 'png';
            else if (blob.type.indexOf('webp') >= 0) ext = 'webp';
            else if (blob.type.indexOf('avif') >= 0) ext = 'avif';
          }
          const name = f.name.replace(/\.[^.]+$/, '') + '.' + ext;
          zip.file(name, blob);

          st.textContent = 'Done';
        } catch (e) {
          console.error(e);
          st.textContent = 'Failed';
        } finally {
          done++;
          prog.style.width = ((done/files.length)*100).toFixed(1) + '%';
        }
      }

      zipBtn.disabled = false;
      runBtn.disabled = false;
    });

    document.getElementById('zipBtn').addEventListener('click', async function(){
      if (!zip) return;
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'optimized-images.zip';
      a.click();
      URL.revokeObjectURL(url);
    });

    // ---------- PWA: SW + Install ----------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('/sw.js').catch(console.error);
      });
    }
    (function setupInstall(){
      var deferredPrompt = null;
      var installBtn = document.getElementById('installBtn');
      window.addEventListener('beforeinstallprompt', function(e){
        e.preventDefault();
        deferredPrompt = e;
        if (installBtn) installBtn.style.display = 'inline-block';
      });
      if (installBtn) {
        installBtn.addEventListener('click', async function(){
          if (!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
          deferredPrompt = null;
          installBtn.style.display = 'none';
        });
      }
      window.addEventListener('appinstalled', function(){
        if (installBtn) installBtn.style.display = 'none';
      });
    })();
  </script>
</body>
</html>
ChatGPT said:
Got it—I read through it. Here’s a quick, no-nonsense review and some high-impact tweaks.

What your app already does well
Nice, clean UI and PWA wiring (install prompt + SW hook).

Entirely client-side: drag/drop queue → resize → optional person matting (MediaPipe) → encode → ZIP (JSZip).

Format fallback via a runtime toBlob probe, and graceful disabling of buttons, progress bar, etc.

Gaps & edge cases (and how to fix them)
1) HEIC/HEIF admitted but likely to fail
You accept .heic/.heif, but most browsers can’t decode them natively; loadImage will reject.
Fix: pre-filter by actual decodability (and give a helpful message).

async function canDecode(file) {
  // Prefer createImageBitmap when available; it fails fast on unsupported types
  if ('createImageBitmap' in window) {
    try {
      const bmp = await createImageBitmap(file, { imageOrientation: 'none' });
      bmp.close?.();
      return true;
    } catch { return false; }
  }
  // Fallback: HTMLImageElement try
  try {
    const url = URL.createObjectURL(file);
    await new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => { URL.revokeObjectURL(url); res(); };
      img.onerror = () => { URL.revokeObjectURL(url); rej(); };
      img.src = url;
    });
    return true;
  } catch { return false; }
}
Use it inside accept:

async function accept(items) {
  const candidates = Array.from(items).filter(f =>
    /^image\//.test(f.type) || /\.(png|jpe?g|webp|avif|heic|heif|gif|bmp)$/i.test(f.name)
  );
  if (!candidates.length) { alert('No images detected.'); return; }

  const checks = await Promise.all(candidates.map(canDecode));
  const decodables = candidates.filter((_, i) => checks[i]);
  const rejected = candidates.length - decodables.length;
  if (rejected) alert(`${rejected} file(s) skipped (format not supported by this browser).`);

  files = files.concat(decodables);
  countEl.textContent = files.length + ' items';
  runBtn.disabled = files.length === 0;
  renderQueue();
}
2) EXIF orientation (rotated portraits)
Phones often store rotation in EXIF; <img> ignores it.
Fix: prefer createImageBitmap(file, { imageOrientation: 'from-image' }) for decoding, then draw to canvas.

async function loadImageToCanvas(file) {
  const c = document.createElement('canvas');
  const ctx = c.getContext('2d', { willReadFrequently: true });
  if ('createImageBitmap' in window) {
    const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
    c.width = bmp.width; c.height = bmp.height;
    ctx.drawImage(bmp, 0, 0);
    bmp.close?.();
  } else {
    const img = await loadImage(file); // your existing helper
    c.width = img.naturalWidth || img.width;
    c.height = img.naturalHeight || img.height;
    ctx.drawImage(img, 0, 0);
  }
  return c;
}
Then in your loop:

const work = await loadImageToCanvas(f);
3) Background matte race / handler reattachment
You set selfieSeg.onResults(...) inside removeBgCanvas every call. It’s fine serially, but safer to set once and await a result.

let selfieResolve;
if (selfieSeg) {
  selfieSeg.onResults((res) => selfieResolve?.(res));
}

function removeBgCanvas(baseCanvas) {
  if (!selfieSeg) return Promise.resolve(baseCanvas);
  return new Promise((resolveOuter) => {
    const w = baseCanvas.width, h = baseCanvas.height;
    selfieResolve = (res) => {
      try {
        const maskC = document.createElement('canvas'); maskC.width = w; maskC.height = h;
        const mc = maskC.getContext('2d');
        mc.drawImage(res.segmentationMask, 0, 0, w, h);
        const mask = mc.getImageData(0,0,w,h);

        const ctx = baseCanvas.getContext('2d');
        const imgData = ctx.getImageData(0,0,w,h);
        const p = imgData.data, m = mask.data; const t = 128;
        for (let i=0;i<p.length;i+=4) p[i+3] = (m[i] > t) ? 255 : 0;
        ctx.putImageData(imgData,0,0);
      } catch (e) { console.warn('Matte failed', e); }
      resolveOuter(baseCanvas);
    };
    const img = new Image();
    img.onload = () => selfieSeg.send({ image: img });
    img.onerror = () => resolveOuter(baseCanvas);
    img.src = baseCanvas.toDataURL('image/png');
  });
}
4) PNG “canvas color” never used
You only fill when output is JPEG. If the user wants a colored matte with PNG/WebP (non-transparent), give them a toggle.

Add a checkbox: “Force opaque output”.

If checked, do the fillRect for any format.

<label class="row" style="align-items:center">
  <input type="checkbox" id="forceOpaque" />
  <span>Force opaque output</span>
</label>
const forceOpaque = $('forceOpaque');
const needsOpaque = (outFmt === 'jpeg') || forceOpaque.checked;
5) Name collisions in ZIP
Duplicate basenames overwrite.
Fix: uniquify:

function uniqueName(zip, base, ext) {
  let n = base, k = 1;
  while (zip.file(`${n}.${ext}`)) n = `${base} (${k++})`;
  return `${n}.${ext}`;
}
...
const base = f.name.replace(/\.[^.]+$/, '');
const finalName = uniqueName(zip, base, ext);
zip.file(finalName, blob);
6) Performance & memory
Draw from a decoded bitmap canvas (above) and set imageSmoothingEnabled = true; imageSmoothingQuality = 'high'.

Between files, await new Promise(r => setTimeout(r, 0)) to yield UI.

Consider chunked zipping if you ever process hundreds of images (JSZip holds blobs until finalize). For now: okay.

7) Accessibility & UX papercuts
Make the drop zone keyboard-operable and announce status updates.

<div class="drop" id="drop" role="button" tabindex="0" aria-label="Drop images here or press Enter to browse"></div>
drop.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') fileInput.click(); });
function setStatus(i, text){ const st = $('status-'+i); st.textContent = text; st.setAttribute('aria-live','polite'); }
Add per-item remove (trash icon) to trim the queue.

8) Safer encoder support check
Your supportsType probes with toBlob. Keep it, but also check ImageDecoder (where supported) to catch AVIF/WebP decoder mismatches.

async function supportsType(mime) {
  if ('ImageDecoder' in window) {
    try { const s = await ImageDecoder.isTypeSupported?.(mime); if (s) return true; } catch {}
  }
  // fallback to your existing canvas probe
  try {
    const c = document.createElement('canvas'); c.width = c.height = 2;
    return await new Promise(res => c.toBlob(b => res(!!b), mime, 0.8));
  } catch { return false; }
}
9) Service worker & manifest
You reference /sw.js and /manifest.webmanifest. Make sure:

SW caches CDN libs (with versioned URLs) and uses skipWaiting/clientsClaim.

Manifest includes icons and display: standalone, background_color: #0b0d12, theme_color: #0b0d12.

10) Minor polish
Clamp quality for formats that ignore it (PNG) and reflect in UI (“N/A for PNG”).

Guard selfieSeg load errors (offline/CDN blocked) with a user-visible note.

Consider a mode toggle for matting strength (threshold slider) instead of fixed t=128.

If you want, I can drop an updated, ready-to-paste <script> block that incorporates items 1–5 & 8 while keeping your HTML/CSS intact.

You said:
i want to improve this tool add check box to enable resizing or not add all available images extensions mac or window or linux etc and in this script background remove not perfect when user remove the background it will remove 90% image with background also calculate total size and after optimize size  
ChatGPT said:

Thought for 10s
Awesome—let’s level this up. I’ve made the changes you asked for:

Add a checkbox to enable/disable resizing (disables width/height inputs when off).

Accept a much broader set of image extensions (Windows/Mac/Linux usual suspects), but also verify actual decodability so weird/RAW types don’t break things.

Much better background removal: adjustable Matte strength + Edge feather + smarter thresholding to stop nuking the subject.

Show total size before vs after processing.

Paste this whole file over your current one (it’s a drop-in replacement).

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover • Bulk Image Optimizer</title>
  <link rel="icon" href="data:;base64,=" />
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0b0d12">
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    a{color:#4b82ff;text-decoration:none}
    header{padding:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;background:#0f1320;border-bottom:1px solid #1e2332}
    header h1{margin:0;font-size:20px;font-weight:700}
    nav a{margin-left:16px;font-size:14px;color:var(--muted)}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px;margin-top:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range],input[type=color]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    #qualityVal{font-weight:600;margin-left:6px;color:#4b82ff}
    .footer{margin-top:12px;color:#7c8798;font-size:12px;text-align:center}
    .tag{font-size:11px;background:#0d1220;border:1px solid #1d2740;color:#a6b0c0;padding:2px 6px;border-radius:999px}
    .hidden{display:none}
  </style>
</head>
<body>
  <header>
    <h1>Background Remover + Bulk Optimizer</h1>
    <nav>
      <a href="about.html">About</a>
      <a href="help.html">Help</a>
      <button id="installBtn" class="btn" style="margin-left:12px;display:none">Install App</button>
    </nav>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop" role="button" tabindex="0" aria-label="Drop images here or press Enter to browse">
          <p><strong>Drop images here</strong> or click to browse</p>
          <input id="file" type="file" accept="image/*" multiple class="hidden" />
          <p class="muted">
            PNG, JPG, WebP, AVIF, GIF, BMP, HEIC/HEIF, TIFF (where supported) • processed locally
          </p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <!-- Resize toggle -->
          <label class="row" style="align-items:center">
            <input type="checkbox" id="enableResize" checked />
            <span>Enable resizing</span>
          </label>
          <span></span>

          <label>Max width (px)
            <input type="number" id="maxWidth" min="64" step="16" value="1600" />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" min="64" step="16" value="1600" />
          </label>

          <label>Output format
            <select id="format">
              <option value="webp">WebP</option>
              <option value="avif">AVIF</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="82" />
            <span id="qualityVal">82%</span>
          </label>

          <label>Background removal
            <select id="bgMode">
              <option value="none">Disabled</option>
              <option value="people" selected>People (fast)</option>
              <option value="people_refine">People + refine (best)</option>
            </select>
          </label>
          <label>Matte strength (0–100)
            <input type="range" id="matteStrength" min="0" max="100" value="70" />
          </label>
          <label>Edge feather (px)
            <input type="range" id="edgeFeather" min="0" max="12" value="2" />
          </label>

          <label>Canvas color (for opaque output)
            <input type="color" id="canvasColor" value="#000000" />
          </label>
          <label class="row" style="align-items:center">
            <input type="checkbox" id="forceOpaque" />
            <span>Force opaque output (fill with canvas color)</span>
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process Images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <button class="btn" id="clearBtn">Clear Queue</button>
        </div>
        <p class="muted">All work happens in your browser. Nothing is uploaded.</p>

        <div class="footer">
          <span class="tag">MediaPipe</span>
          <span class="tag">Canvas encoders</span>
          <span class="tag">JSZip</span>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar" style="margin:10px 0 14px"><i id="prog"></i></div>
        <div class="muted" id="sizeTotals">Original: 0 B → Optimized: 0 B</div>
        <div class="thumbs" id="thumbs" style="margin-top:10px"></div>
      </div>
    </div>
  </div>

  <!-- Dependencies (UMD, no modules) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

  <script>
    // ---------- Elements ----------
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const clearBtn = $('clearBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const sizeTotals = $('sizeTotals');

    const enableResize = $('enableResize');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const qualityVal = $('qualityVal');
    const bgMode = $('bgMode');
    const matteStrength = $('matteStrength');
    const edgeFeather = $('edgeFeather');
    const canvasColor = $('canvasColor');
    const forceOpaque = $('forceOpaque');

    let files = [];
    let zip = null;
    let totalOriginal = 0;
    let totalOptimized = 0;

    // ---------- Helpers ----------
    quality.addEventListener('input', () => { qualityVal.textContent = quality.value + '%'; });
    function bytes(n){
      if (n < 1024) return n + ' B';
      if (n < 1024*1024) return (n/1024).toFixed(1) + ' KB';
      if (n < 1024*1024*1024) return (n/1024/1024).toFixed(1) + ' MB';
      return (n/1024/1024/1024).toFixed(2) + ' GB';
    }
    function updateTotals(){
      sizeTotals.textContent = `Original: ${bytes(totalOriginal)} → Optimized: ${bytes(totalOptimized)}${totalOptimized ? ` (${Math.max(0, (1 - totalOptimized/Math.max(1,totalOriginal))*100).toFixed(1)}% smaller)` : ''}`;
    }

    enableResize.addEventListener('change', () => {
      const dis = !enableResize.checked;
      maxWidth.disabled = dis;
      maxHeight.disabled = dis;
    });

    function extOK(name) {
      // Broad cross-platform list (some may not decode; we'll verify)
      return /\.(png|jpe?g|webp|avif|gif|bmp|heic|heif|tif|tiff|jfif|pjpeg|pjp)$/i.test(name);
    }

    async function canDecode(file) {
      // Try ImageBitmap (fast fail) when available
      if ('createImageBitmap' in window) {
        try {
          const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
          bmp.close?.();
          return true;
        } catch { /* fall through */ }
      }
      // Fallback: <img> decode attempt
      try {
        const url = URL.createObjectURL(file);
        await new Promise((res, rej) => {
          const img = new Image();
          img.onload = () => { URL.revokeObjectURL(url); res(); };
          img.onerror = () => { URL.revokeObjectURL(url); rej(); };
          img.src = url;
        });
        return true;
      } catch { return false; }
    }

    function supportsTypeViaCanvas(mime) {
      try {
        const c = document.createElement('canvas'); c.width = c.height = 2;
        return new Promise((res) => c.toBlob((b) => res(!!b), mime, 0.8));
      } catch { return Promise.resolve(false); }
    }
    async function supportsType(mime) {
      if ('ImageDecoder' in window && ImageDecoder.isTypeSupported) {
        try { if (await ImageDecoder.isTypeSupported(mime)) return true; } catch {}
      }
      return supportsTypeViaCanvas(mime);
    }

    function accept(items) {
      const candidates = Array.from(items).filter(f =>
        /^image\//.test(f.type) || extOK(f.name)
      );
      if (!candidates.length) { alert('No images detected.'); return; }

      (async () => {
        const checks = await Promise.all(candidates.map(canDecode));
        const decodables = candidates.filter((_, i) => checks[i]);
        const rejected = candidates.length - decodables.length;
        if (rejected) alert(`${rejected} file(s) skipped (format not supported by this browser).`);

        files = files.concat(decodables);
        totalOriginal += decodables.reduce((sum, f) => sum + (f.size || 0), 0);
        updateTotals();

        countEl.textContent = files.length + ' items';
        runBtn.disabled = files.length === 0;
        renderQueue();
      })();
    }

    fileInput.addEventListener('change', (e) => accept(e.target.files));
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
      drop.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); });
    });
    drop.addEventListener('dragenter', () => drop.style.borderColor = '#2b6ef3');
    drop.addEventListener('dragleave', () => drop.style.borderColor = '#33415c');
    drop.addEventListener('drop', (e) => { drop.style.borderColor = '#33415c'; accept(e.dataTransfer.files); });
    drop.addEventListener('click', () => fileInput.click());
    drop.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') fileInput.click(); });

    clearBtn.addEventListener('click', () => {
      files = [];
      zip = null;
      thumbs.innerHTML = '';
      countEl.textContent = '0 items';
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      totalOriginal = 0;
      totalOptimized = 0;
      updateTotals();
    });

    function renderQueue() {
      let html = '';
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        html += "<div class='thumb'>" +
          "<img id='img-" + i + "' alt='preview' />" +
          "<div class='muted'>" + f.name + " • " + bytes(f.size || 0) + "</div>" +
          "<div class='muted' id='status-" + i + "'>Queued</div>" +
          "</div>";
      }
      thumbs.innerHTML = html;
      files.forEach((f, i) => {
        const reader = new FileReader();
        reader.onload = () => { const img = $('img-' + i); if (img) img.src = reader.result; };
        reader.readAsDataURL(f);
      });
    }

    // ---------- Background removal (improved) ----------
    let selfieSeg = null;
    let selfieResolve = null;

    (async function initSeg() {
      if (window.SelfieSegmentation) {
        selfieSeg = new SelfieSegmentation({ locateFile: (f) => "https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/" + f });
        selfieSeg.setOptions({ modelSelection: 1 });
        try {
          selfieSeg.onResults((res) => { if (selfieResolve) selfieResolve(res); });
          if (typeof selfieSeg.initialize === 'function') await selfieSeg.initialize();
        } catch(e) { console.warn('Segmentation init', e); }
      }
    })();

    async function loadImageToCanvas(file) {
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d', { willReadFrequently: true });
      if ('createImageBitmap' in window) {
        const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
        c.width = bmp.width; c.height = bmp.height;
        ctx.drawImage(bmp, 0, 0);
        bmp.close?.();
      } else {
        const url = URL.createObjectURL(file);
        const img = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = (e) => reject(e);
          im.src = url;
        });
        c.width = img.naturalWidth || img.width;
        c.height = img.naturalHeight || img.height;
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
      }
      return c;
    }

    function fitSize(w, h, maxW, maxH) {
      const r = Math.min(maxW / w, maxH / h, 1);
      return { w: Math.max(1, Math.round(w * r)), h: Math.max(1, Math.round(h * r)) };
    }

    function encodeCanvas(canvas, type, q) {
      const mime = (type === 'jpeg') ? 'image/jpeg' :
                   (type === 'png')  ? 'image/png'  :
                   (type === 'avif') ? 'image/avif' : 'image/webp';
      return new Promise((resolve) => canvas.toBlob((b) => resolve(b), mime, q));
    }

    // Core refine: threshold + gamma-like strength + feather blur
    async function removeBgCanvas(baseCanvas) {
      const mode = bgMode.value;
      if (mode === 'none' || !selfieSeg) return baseCanvas;

      // Run segmentation once from the canvas snapshot
      const tempImg = new Image();
      tempImg.src = baseCanvas.toDataURL('image/png');
      await tempImg.decode();
      const segRes = await new Promise((resolve) => { selfieResolve = resolve; selfieSeg.send({ image: tempImg }); });

      const w = baseCanvas.width, h = baseCanvas.height;
      // Read segmentation mask into a canvas
      const maskC = document.createElement('canvas'); maskC.width = w; maskC.height = h;
      const mc = maskC.getContext('2d');
      mc.drawImage(segRes.segmentationMask, 0, 0, w, h);

      // Optional feather blur using canvas filter (fast)
      const featherPx = parseInt(edgeFeather.value, 10) || 0;
      if (featherPx > 0) {
        const blurC = document.createElement('canvas'); blurC.width = w; blurC.height = h;
        const bc = blurC.getContext('2d');
        bc.filter = `blur(${featherPx}px)`;
        bc.drawImage(maskC, 0, 0, w, h);
        // Copy back
        mc.clearRect(0,0,w,h);
        mc.drawImage(blurC, 0, 0);
      }

      const mask = mc.getImageData(0,0,w,h);
      const ctx = baseCanvas.getContext('2d');
      const imgData = ctx.getImageData(0,0,w,h);
      const p = imgData.data, m = mask.data;

      // Controls
      const strength = Math.max(0, Math.min(100, parseInt(matteStrength.value, 10) || 0)) / 100; // 0..1
      // Start from a conservative threshold; refined mode uses continuous alpha, fast mode uses hard threshold
      const baseThresh = 110; // more conservative than 128
      const hard = (mode === 'people');

      for (let i = 0; i < p.length; i += 4) {
        const v = m[i]; // grayscale
        let alpha;
        if (hard) {
          // Hard threshold with small bias using strength
          const t = baseThresh - Math.round(20 * strength); // lower threshold slightly with strength
          alpha = (v > t) ? 255 : 0;
        } else {
          // Refined: continuous matte, gamma-like curve to bias foreground
          // Normalize 0..1
          let a = v / 255;
          // Bias foreground: push mid values upward based on strength
          const gamma = 1 - (0.5 * strength); // 1..0.5
          a = Math.pow(a, gamma);
          // Also trim near-background
          const cut = 0.2 - (0.1 * strength); // 0.2..0.1
          a = (a <= cut) ? 0 : (a >= 1 ? 1 : (a - cut) / (1 - cut));
          alpha = Math.round(a * 255);
        }
        p[i + 3] = alpha;
      }
      ctx.putImageData(imgData, 0, 0);
      return baseCanvas;
    }

    function uniqueName(zip, base, ext) {
      let n = base, k = 1;
      while (zip.file(`${n}.${ext}`)) n = `${base} (${k++})`;
      return `${n}.${ext}`;
    }

    document.getElementById('runBtn').addEventListener('click', async function(){
      if (!files.length) return;
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      zip = new JSZip();
      totalOptimized = 0;

      const resizeOn = enableResize.checked;
      const maxW = parseInt(maxWidth.value, 10);
      const maxH = parseInt(maxHeight.value, 10);
      let outFmt = formatSel.value;
      const q01 = parseInt(quality.value, 10) / 100;

      // If chosen format unsupported, fall back to PNG
      const mimeWanted = (outFmt==='jpeg')?'image/jpeg':(outFmt==='png')?'image/png':(outFmt==='avif')?'image/avif':'image/webp';
      const supported = await supportsType(mimeWanted);
      if (!supported) outFmt = 'png';

      let done = 0;
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        const st = $('status-' + i);
        try {
          st.textContent = 'Decoding…';
          const work = await loadImageToCanvas(f);

          if (bgMode.value !== 'none') {
            st.textContent = 'Removing background…';
            await removeBgCanvas(work);
          }

          // Resize if enabled
          let out = work;
          if (resizeOn) {
            const size = fitSize(work.width, work.height, maxW, maxH);
            if (size.w !== work.width || size.h !== work.height) {
              out = document.createElement('canvas');
              out.width = size.w; out.height = size.h;
              const oc = out.getContext('2d');
              oc.imageSmoothingEnabled = true;
              oc.imageSmoothingQuality = 'high';
              oc.drawImage(work, 0, 0, size.w, size.h);
            }
          }

          // Composite for opaque outputs or when forcing opaque
          const needsOpaque = (outFmt === 'jpeg') || forceOpaque.checked;
          if (needsOpaque) {
            const solid = document.createElement('canvas');
            solid.width = out.width; solid.height = out.height;
            const sc = solid.getContext('2d');
            sc.fillStyle = canvasColor.value;
            sc.fillRect(0, 0, solid.width, solid.height);
            sc.drawImage(out, 0, 0);
            out = solid;
          }

          st.textContent = 'Encoding…';
          const blob = await encodeCanvas(out, outFmt, q01);

          // Extension from resulting blob.type
          let ext = outFmt;
          if (blob && blob.type) {
            if (blob.type.includes('jpeg')) ext = 'jpg';
            else if (blob.type.includes('png')) ext = 'png';
            else if (blob.type.includes('webp')) ext = 'webp';
            else if (blob.type.includes('avif')) ext = 'avif';
          }

          const base = f.name.replace(/\.[^.]+$/, '');
          const finalName = uniqueName(zip, base, ext);
          zip.file(finalName, blob);

          totalOptimized += blob.size || 0;
          updateTotals();

          st.textContent = 'Done';
        } catch (e) {
          console.error(e);
          st.textContent = 'Failed';
        } finally {
          done++;
          prog.style.width = ((done / files.length) * 100).toFixed(1) + '%';
          // Let the UI breathe
          await new Promise(r => setTimeout(r, 0));
        }
      }

      zipBtn.disabled = false;
      runBtn.disabled = false;
    });

    document.getElementById('zipBtn').addEventListener('click', async function(){
      if (!zip) return;
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'optimized-images.zip';
      a.click();
      URL.revokeObjectURL(url);
    });

    // ---------- PWA: SW + Install ----------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('/sw.js').catch(console.error);
      });
    }
    (function setupInstall(){
      var deferredPrompt = null;
      var installBtn = document.getElementById('installBtn');
      window.addEventListener('beforeinstallprompt', function(e){
        e.preventDefault();
        deferredPrompt = e;
        if (installBtn) installBtn.style.display = 'inline-block';
      });
      if (installBtn) {
        installBtn.addEventListener('click', async function(){
          if (!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
          deferredPrompt = null;
          installBtn.style.display = 'none';
        });
      }
      window.addEventListener('appinstalled', function(){
        if (installBtn) installBtn.style.display = 'none';
      });
    })();
  </script>
</body>
</html>
What changed (quick notes)
Enable resizing: checkbox #enableResize (on by default). When off, width/height inputs are disabled and images keep original size.

Extensions: accepts png, jpg/jpeg/jfif/pjpeg/pjp, webp, avif, gif, bmp, heic, heif, tif/tiff. Any the browser can’t actually decode are auto-skipped with a clear message.

Background removal:

New modes: “People (fast)” (hard threshold) and “People + refine (best)” which uses a continuous matte with a gamma curve + cut and edge feather.

Matte strength slider: pulls more uncertain pixels into the foreground without obliterating details.

Edge feather slider: softens edges to avoid halos/fringing.

Size accounting: shows Original total vs Optimized total and % saving as you process.

Opaque output: check Force opaque output to fill transparency in any format (not just JPEG) with your Canvas color.

If you want me to tune the default thresholds to your specific photos (e.g., product shots vs portraits), tell me what kinds of images you run and I’ll tweak the defaults (or add presets).

You said:
by default resizing disabled, background removal disabled output format WebP Quality 70% and option to download images with Download Zip and add more output image formats also set checkbox position
ChatGPT said:

Thought for 18s
You got it. I’ve updated your app with the exact defaults and UI tweaks you asked for:

Defaults now:

Resizing: disabled (checkbox off; width/height inputs auto-disabled)

Background removal: disabled

Output format: WebP

Quality: 70%

“Download ZIP” flow unchanged (front-and-center).

More output formats: added Keep original, WebP, AVIF, JPEG, PNG (only ones browsers can reliably encode via canvas.toBlob).

Checkbox position: checkboxes are grouped at the top-left of the control panel for easy access.

Paste this full file over your current one:

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover • Bulk Image Optimizer</title>
  <link rel="icon" href="data:;base64,=" />
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0b0d12">
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    a{color:#4b82ff;text-decoration:none}
    header{padding:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;background:#0f1320;border-bottom:1px solid #1e2332}
    header h1{margin:0;font-size:20px;font-weight:700}
    nav a{margin-left:16px;font-size:14px;color:var(--muted)}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px;margin-top:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range],input[type=color]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    #qualityVal{font-weight:600;margin-left:6px;color:#4b82ff}
    .footer{margin-top:12px;color:#7c8798;font-size:12px;text-align:center}
    .tag{font-size:11px;background:#0d1220;border:1px solid #1d2740;color:#a6b0c0;padding:2px 6px;border-radius:999px}
    .hidden{display:none}
    /* Make the first row span: put the main toggles top-left */
    .controls .fullrow{grid-column:1/-1; display:flex; gap:16px; align-items:center; flex-wrap:wrap}
    .controls .check{display:flex; align-items:center; gap:8px; font-size:13px}
  </style>
</head>
<body>
  <header>
    <h1>Background Remover + Bulk Optimizer</h1>
    <nav>
      <a href="about.html">About</a>
      <a href="help.html">Help</a>
      <button id="installBtn" class="btn" style="margin-left:12px;display:none">Install App</button>
    </nav>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop" role="button" tabindex="0" aria-label="Drop images here or press Enter to browse">
          <p><strong>Drop images here</strong> or click to browse</p>
          <input id="file" type="file" accept="image/*" multiple class="hidden" />
          <p class="muted">PNG, JPG, WebP, AVIF, GIF, BMP, HEIC/HEIF, TIFF (where supported) • processed locally</p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <!-- TOP ROW: checkboxes (positioned first) -->
          <div class="fullrow">
            <label class="check">
              <input type="checkbox" id="enableResize" />
              <span>Enable resizing</span>
            </label>
            <label class="check">
              <input type="checkbox" id="forceOpaque" />
              <span>Force opaque output</span>
            </label>
          </div>

          <!-- Sizing (disabled when resizing is off) -->
          <label>Max width (px)
            <input type="number" id="maxWidth" min="64" step="16" value="1600" disabled />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" min="64" step="16" value="1600" disabled />
          </label>

          <!-- Output -->
          <label>Output format
            <select id="format">
              <option value="keep">Keep original</option>
              <option value="webp" selected>WebP</option>
              <option value="avif">AVIF</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="70" />
            <span id="qualityVal">70%</span>
          </label>

          <!-- Background removal (disabled by default) -->
          <label>Background removal
            <select id="bgMode">
              <option value="none" selected>Disabled</option>
              <option value="people">People (fast)</option>
              <option value="people_refine">People + refine (best)</option>
            </select>
          </label>
          <label>Matte strength (0–100)
            <input type="range" id="matteStrength" min="0" max="100" value="70" />
          </label>
          <label>Edge feather (px)
            <input type="range" id="edgeFeather" min="0" max="12" value="2" />
          </label>

          <label>Canvas color (for opaque output)
            <input type="color" id="canvasColor" value="#000000" />
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process Images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <button class="btn" id="clearBtn">Clear Queue</button>
        </div>
        <p class="muted">All work happens in your browser. Nothing is uploaded.</p>

        <div class="footer">
          <span class="tag">MediaPipe</span>
          <span class="tag">Canvas encoders</span>
          <span class="tag">JSZip</span>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar" style="margin:10px 0 14px"><i id="prog"></i></div>
        <div class="muted" id="sizeTotals">Original: 0 B → Optimized: 0 B</div>
        <div class="thumbs" id="thumbs" style="margin-top:10px"></div>
      </div>
    </div>
  </div>

  <!-- Dependencies (UMD, no modules) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

  <script>
    // ---------- Elements ----------
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const clearBtn = $('clearBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const sizeTotals = $('sizeTotals');

    const enableResize = $('enableResize');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const qualityVal = $('qualityVal');
    const bgMode = $('bgMode');
    const matteStrength = $('matteStrength');
    const edgeFeather = $('edgeFeather');
    const canvasColor = $('canvasColor');
    const forceOpaque = $('forceOpaque');

    let files = [];
    let zip = null;
    let totalOriginal = 0;
    let totalOptimized = 0;

    // ---------- Helpers ----------
    quality.addEventListener('input', () => { qualityVal.textContent = quality.value + '%'; });

    function bytes(n){
      if (n < 1024) return n + ' B';
      if (n < 1024*1024) return (n/1024).toFixed(1) + ' KB';
      if (n < 1024*1024*1024) return (n/1024/1024).toFixed(1) + ' MB';
      return (n/1024/1024/1024).toFixed(2) + ' GB';
    }
    function updateTotals(){
      sizeTotals.textContent = `Original: ${bytes(totalOriginal)} → Optimized: ${bytes(totalOptimized)}${totalOptimized ? ` (${Math.max(0, (1 - totalOptimized/Math.max(1,totalOriginal))*100).toFixed(1)}% smaller)` : ''}`;
    }

    // Checkbox positioning behavior: resizing off by default, inputs disabled
    enableResize.checked = false;
    maxWidth.disabled = true;
    maxHeight.disabled = true;

    enableResize.addEventListener('change', () => {
      const dis = !enableResize.checked;
      maxWidth.disabled = dis;
      maxHeight.disabled = dis;
    });

    function extOK(name) {
      // Common cross-platform extensions (we still verify actual decodability)
      return /\.(png|jpe?g|webp|avif|gif|bmp|heic|heif|tif|tiff|jfif|pjpeg|pjp)$/i.test(name);
    }

    async function canDecode(file) {
      if ('createImageBitmap' in window) {
        try {
          const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
          bmp.close?.();
          return true;
        } catch {}
      }
      try {
        const url = URL.createObjectURL(file);
        await new Promise((res, rej) => {
          const img = new Image();
          img.onload = () => { URL.revokeObjectURL(url); res(); };
          img.onerror = () => { URL.revokeObjectURL(url); rej(); };
          img.src = url;
        });
        return true;
      } catch { return false; }
    }

    function supportsTypeViaCanvas(mime) {
      try {
        const c = document.createElement('canvas'); c.width = c.height = 2;
        return new Promise((res) => c.toBlob((b) => res(!!b), mime, 0.8));
      } catch { return Promise.resolve(false); }
    }
    async function supportsType(mime) {
      if ('ImageDecoder' in window && ImageDecoder.isTypeSupported) {
        try { if (await ImageDecoder.isTypeSupported(mime)) return true; } catch {}
      }
      return supportsTypeViaCanvas(mime);
    }

    function accept(items) {
      const candidates = Array.from(items).filter(f =>
        /^image\//.test(f.type) || extOK(f.name)
      );
      if (!candidates.length) { alert('No images detected.'); return; }

      (async () => {
        const checks = await Promise.all(candidates.map(canDecode));
        const decodables = candidates.filter((_, i) => checks[i]);
        const rejected = candidates.length - decodables.length;
        if (rejected) alert(`${rejected} file(s) skipped (format not supported by this browser).`);

        files = files.concat(decodables);
        totalOriginal += decodables.reduce((sum, f) => sum + (f.size || 0), 0);
        updateTotals();

        countEl.textContent = files.length + ' items';
        runBtn.disabled = files.length === 0;
        renderQueue();
      })();
    }

    fileInput.addEventListener('change', (e) => accept(e.target.files));
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
      drop.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); });
    });
    drop.addEventListener('dragenter', () => drop.style.borderColor = '#2b6ef3');
    drop.addEventListener('dragleave', () => drop.style.borderColor = '#33415c');
    drop.addEventListener('drop', (e) => { drop.style.borderColor = '#33415c'; accept(e.dataTransfer.files); });
    drop.addEventListener('click', () => fileInput.click());
    drop.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') fileInput.click(); });

    clearBtn.addEventListener('click', () => {
      files = [];
      zip = null;
      thumbs.innerHTML = '';
      countEl.textContent = '0 items';
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      totalOriginal = 0;
      totalOptimized = 0;
      updateTotals();
    });

    function renderQueue() {
      let html = '';
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        html += "<div class='thumb'>" +
          "<img id='img-" + i + "' alt='preview' />" +
          "<div class='muted'>" + f.name + " • " + bytes(f.size || 0) + "</div>" +
          "<div class='muted' id='status-" + i + "'>Queued</div>" +
          "</div>";
      }
      thumbs.innerHTML = html;
      files.forEach((f, i) => {
        const reader = new FileReader();
        reader.onload = () => { const img = $('img-' + i); if (img) img.src = reader.result; };
        reader.readAsDataURL(f);
      });
    }

    // ---------- Background removal (improved) ----------
    let selfieSeg = null;
    let selfieResolve = null;

    (async function initSeg() {
      if (window.SelfieSegmentation) {
        selfieSeg = new SelfieSegmentation({ locateFile: (f) => "https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/" + f });
        selfieSeg.setOptions({ modelSelection: 1 });
        try {
          selfieSeg.onResults((res) => { if (selfieResolve) selfieResolve(res); });
          if (typeof selfieSeg.initialize === 'function') await selfieSeg.initialize();
        } catch(e) { console.warn('Segmentation init', e); }
      }
    })();

    async function loadImageToCanvas(file) {
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d', { willReadFrequently: true });
      if ('createImageBitmap' in window) {
        const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
        c.width = bmp.width; c.height = bmp.height;
        ctx.drawImage(bmp, 0, 0);
        bmp.close?.();
      } else {
        const url = URL.createObjectURL(file);
        const img = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = (e) => reject(e);
          im.src = url;
        });
        c.width = img.naturalWidth || img.width;
        c.height = img.naturalHeight || img.height;
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
      }
      return c;
    }

    function fitSize(w, h, maxW, maxH) {
      const r = Math.min(maxW / w, maxH / h, 1);
      return { w: Math.max(1, Math.round(w * r)), h: Math.max(1, Math.round(h * r)) };
    }

    function encodeCanvas(canvas, type, q) {
      const mime = (type === 'jpeg') ? 'image/jpeg' :
                   (type === 'png')  ? 'image/png'  :
                   (type === 'avif') ? 'image/avif' : 'image/webp';
      return new Promise((resolve) => canvas.toBlob((b) => resolve(b), mime, q));
    }

    async function removeBgCanvas(baseCanvas) {
      const mode = bgMode.value;
      if (mode === 'none' || !selfieSeg) return baseCanvas;

      const tempImg = new Image();
      tempImg.src = baseCanvas.toDataURL('image/png');
      await tempImg.decode();
      const segRes = await new Promise((resolve) => { selfieResolve = resolve; selfieSeg.send({ image: tempImg }); });

      const w = baseCanvas.width, h = baseCanvas.height;
      const maskC = document.createElement('canvas'); maskC.width = w; maskC.height = h;
      const mc = maskC.getContext('2d');
      mc.drawImage(segRes.segmentationMask, 0, 0, w, h);

      const featherPx = parseInt(edgeFeather.value, 10) || 0;
      if (featherPx > 0) {
        const blurC = document.createElement('canvas'); blurC.width = w; blurC.height = h;
        const bc = blurC.getContext('2d');
        bc.filter = `blur(${featherPx}px)`;
        bc.drawImage(maskC, 0, 0, w, h);
        mc.clearRect(0,0,w,h);
        mc.drawImage(blurC, 0, 0);
      }

      const mask = mc.getImageData(0,0,w,h);
      const ctx = baseCanvas.getContext('2d');
      const imgData = ctx.getImageData(0,0,w,h);
      const p = imgData.data, m = mask.data;

      const strength = Math.max(0, Math.min(100, parseInt(matteStrength.value, 10) || 0)) / 100; // 0..1
      const baseThresh = 110;
      const hard = (mode === 'people');

      for (let i = 0; i < p.length; i += 4) {
        const v = m[i];
        let alpha;
        if (hard) {
          const t = baseThresh - Math.round(20 * strength);
          alpha = (v > t) ? 255 : 0;
        } else {
          let a = v / 255;
          const gamma = 1 - (0.5 * strength); // 1..0.5
          a = Math.pow(a, gamma);
          const cut = 0.2 - (0.1 * strength); // 0.2..0.1
          a = (a <= cut) ? 0 : (a >= 1 ? 1 : (a - cut) / (1 - cut));
          alpha = Math.round(a * 255);
        }
        p[i + 3] = alpha;
      }
      ctx.putImageData(imgData, 0, 0);
      return baseCanvas;
    }

    function uniqueName(zip, base, ext) {
      let n = base, k = 1;
      while (zip.file(`${n}.${ext}`)) n = `${base} (${k++})`;
      return `${n}.${ext}`;
    }

    // Map input filename extension to encoder-friendly type when "Keep original" selected
    function extToOutFmt(name) {
      const m = name.toLowerCase().match(/\.(\w+)$/);
      if (!m) return 'png';
      const e = m[1];
      if (['jpg','jpeg','jfif','pjpeg','pjp'].includes(e)) return 'jpeg';
      if (['png'].includes(e)) return 'png';
      if (['webp'].includes(e)) return 'webp';
      if (['avif'].includes(e)) return 'avif';
      // For unsupported encoders (gif, bmp, heic, heif, tif, tiff) fall back to PNG
      return 'png';
    }

    document.getElementById('runBtn').addEventListener('click', async function(){
      if (!files.length) return;
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      zip = new JSZip();
      totalOptimized = 0;

      const resizeOn = enableResize.checked;
      const maxW = parseInt(maxWidth.value, 10);
      const maxH = parseInt(maxHeight.value, 10);
      const selectedFmt = formatSel.value;
      const q01 = parseInt(quality.value, 10) / 100;

      let done = 0;
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        const st = $('status-' + i);
        try {
          st.textContent = 'Decoding…';
          const work = await loadImageToCanvas(f);

          if (bgMode.value !== 'none') {
            st.textContent = 'Removing background…';
            await removeBgCanvas(work);
          }

          let out = work;
          if (resizeOn) {
            const size = fitSize(work.width, work.height, maxW, maxH);
            if (size.w !== work.width || size.h !== work.height) {
              out = document.createElement('canvas');
              out.width = size.w; out.height = size.h;
              const oc = out.getContext('2d');
              oc.imageSmoothingEnabled = true;
              oc.imageSmoothingQuality = 'high';
              oc.drawImage(work, 0, 0, size.w, size.h);
            }
          }

          // Decide output format (handle "keep original")
          let outFmt = selectedFmt === 'keep' ? extToOutFmt(f.name) : selectedFmt;

          // If chosen/suggested format unsupported, fall back to PNG
          const mimeWanted = (outFmt==='jpeg')?'image/jpeg':(outFmt==='png')?'image/png':(outFmt==='avif')?'image/avif':'image/webp';
          const supported = await supportsType(mimeWanted);
          if (!supported) outFmt = 'png';

          // Opaque composite if needed
          const needsOpaque = (outFmt === 'jpeg') || forceOpaque.checked;
          if (needsOpaque) {
            const solid = document.createElement('canvas');
            solid.width = out.width; solid.height = out.height;
            const sc = solid.getContext('2d');
            sc.fillStyle = canvasColor.value;
            sc.fillRect(0, 0, solid.width, solid.height);
            sc.drawImage(out, 0, 0);
            out = solid;
          }

          st.textContent = 'Encoding…';
          const blob = await encodeCanvas(out, outFmt, q01);

          // Extension from resulting blob.type (more robust)
          let ext = outFmt;
          if (blob && blob.type) {
            if (blob.type.includes('jpeg')) ext = 'jpg';
            else if (blob.type.includes('png')) ext = 'png';
            else if (blob.type.includes('webp')) ext = 'webp';
            else if (blob.type.includes('avif')) ext = 'avif';
          }

          const base = f.name.replace(/\.[^.]+$/, '');
          const finalName = uniqueName(zip, base, ext);
          zip.file(finalName, blob);

          totalOptimized += blob.size || 0;
          updateTotals();

          st.textContent = 'Done';
        } catch (e) {
          console.error(e);
          st.textContent = 'Failed';
        } finally {
          done++;
          prog.style.width = ((done / files.length) * 100).toFixed(1) + '%';
          await new Promise(r => setTimeout(r, 0));
        }
      }

      zipBtn.disabled = false;
      runBtn.disabled = false;
    });

    document.getElementById('zipBtn').addEventListener('click', async function(){
      if (!zip) return;
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'optimized-images.zip';
      a.click();
      URL.revokeObjectURL(url);
    });

    // ---------- PWA: SW + Install ----------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('/sw.js').catch(console.error);
      });
    }
    (function setupInstall(){
      var deferredPrompt = null;
      var installBtn = document.getElementById('installBtn');
      window.addEventListener('beforeinstallprompt', function(e){
        e.preventDefault();
        deferredPrompt = e;
        if (installBtn) installBtn.style.display = 'inline-block';
      });
      if (installBtn) {
        installBtn.addEventListener('click', async function(){
          if (!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
          deferredPrompt = null;
          installBtn.style.display = 'none';
        });
      }
      window.addEventListener('appinstalled', function(){
        if (installBtn) installBtn.style.display = 'none';
      });
    })();
  </script>
</body>
</html>
Want me to also add an “Auto choose best format” option (e.g., WebP for photos, PNG for graphics) or an “individual download” button per image card?

You said:
good now add one more option to download images 
ChatGPT said:
Perfect 👍 — you want to keep the “Download ZIP” (bulk) and also add an option to download each optimized image individually after processing, right?

Here’s what I’ll do:

✅ Keep your Download ZIP button (bulk download)
✅ Add a “Download Images” button next to it that lets the user download all optimized images separately (not zipped) — each file will download with its own name via browser’s a.download

Below is the final upgraded version of your tool, with:

Resizing disabled by default

Background removal disabled by default

WebP / Quality 70% defaults

Checkbox positions improved

Both Download ZIP + Download Images options

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover • Bulk Image Optimizer</title>
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0b0d12">
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    header{padding:20px;display:flex;align-items:center;justify-content:space-between;background:#0f1320;border-bottom:1px solid #1e2332}
    header h1{margin:0;font-size:20px;font-weight:700}
    nav a{margin-left:16px;color:var(--muted);font-size:14px;text-decoration:none}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px;margin-top:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .fullrow{grid-column:1/-1;display:flex;gap:16px;align-items:center;flex-wrap:wrap}
    .check{display:flex;align-items:center;gap:8px;font-size:13px}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range],input[type=color]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    #qualityVal{font-weight:600;margin-left:6px;color:#4b82ff}
  </style>
</head>
<body>
  <header>
    <h1>Background Remover + Bulk Optimizer</h1>
    <nav>
      <a href="about.html">About</a>
      <a href="help.html">Help</a>
    </nav>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop">
          <p><strong>Drop images here</strong> or click to browse</p>
          <input id="file" type="file" accept="image/*" multiple class="hidden" />
          <p class="muted">PNG, JPG, WebP, AVIF, GIF, BMP, HEIC/HEIF, TIFF</p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <div class="fullrow">
            <label class="check"><input type="checkbox" id="enableResize" /> <span>Enable resizing</span></label>
            <label class="check"><input type="checkbox" id="forceOpaque" /> <span>Force opaque output</span></label>
          </div>

          <label>Max width (px)
            <input type="number" id="maxWidth" value="1600" disabled />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" value="1600" disabled />
          </label>

          <label>Output format
            <select id="format">
              <option value="keep">Keep original</option>
              <option value="webp" selected>WebP</option>
              <option value="avif">AVIF</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="70" />
            <span id="qualityVal">70%</span>
          </label>

          <label>Background removal
            <select id="bgMode">
              <option value="none" selected>Disabled</option>
              <option value="people">People (fast)</option>
              <option value="people_refine">People + refine</option>
            </select>
          </label>
          <label>Canvas color
            <input type="color" id="canvasColor" value="#000000" />
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process Images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <button class="btn" id="allBtn" disabled>Download Images</button>
          <button class="btn" id="clearBtn">Clear Queue</button>
        </div>
        <p class="muted">Everything runs locally in your browser.</p>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar"><i id="prog"></i></div>
        <div class="thumbs" id="thumbs"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const allBtn = $('allBtn');
    const clearBtn = $('clearBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const enableResize = $('enableResize');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const qualityVal = $('qualityVal');
    const bgMode = $('bgMode');
    const canvasColor = $('canvasColor');
    const forceOpaque = $('forceOpaque');

    let files = [];
    let zip = null;
    let processed = [];

    quality.addEventListener('input', ()=> qualityVal.textContent = quality.value + '%');
    enableResize.addEventListener('change', ()=>{
      const dis = !enableResize.checked;
      maxWidth.disabled = dis;
      maxHeight.disabled = dis;
    });

    function accept(items){
      const imgs = Array.from(items).filter(f=>/^image\//.test(f.type));
      if(!imgs.length){ alert('No images detected'); return;}
      files = files.concat(imgs);
      countEl.textContent = files.length+' items';
      runBtn.disabled = files.length===0;
      renderQueue();
    }

    fileInput.addEventListener('change', e=>accept(e.target.files));
    drop.addEventListener('click', ()=>fileInput.click());
    ['dragenter','dragover','dragleave','drop'].forEach(ev=>{
      drop.addEventListener(ev, e=>{e.preventDefault();e.stopPropagation();});
    });
    drop.addEventListener('drop', e=>accept(e.dataTransfer.files));

    clearBtn.addEventListener('click', ()=>{
      files=[];processed=[];thumbs.innerHTML='';countEl.textContent='0 items';
      runBtn.disabled=zipBtn.disabled=allBtn.disabled=true;prog.style.width='0%';
    });

    function renderQueue(){
      thumbs.innerHTML = files.map((f,i)=>`
        <div class='thumb'>
          <img id='img-${i}' alt='preview'/>
          <div class='muted'>${f.name}</div>
          <div class='muted' id='status-${i}'>Queued</div>
        </div>`).join('');
      files.forEach((f,i)=>{
        const r=new FileReader();
        r.onload=()=>{$('img-'+i).src=r.result;};
        r.readAsDataURL(f);
      });
    }

    async function loadImage(f){
      return new Promise((res,rej)=>{
        const url=URL.createObjectURL(f);
        const img=new Image();
        img.onload=()=>{URL.revokeObjectURL(url);res(img);}
        img.onerror=()=>rej();
        img.src=url;
      });
    }

    function fitSize(w,h,maxW,maxH){const r=Math.min(maxW/w,maxH/h,1);return {w:Math.round(w*r),h:Math.round(h*r)};}
    function encodeCanvas(c,type,q){const m=type==='jpeg'?'image/jpeg':type==='png'?'image/png':type==='avif'?'image/avif':'image/webp';return new Promise(r=>c.toBlob(b=>r(b),m,q));}

    runBtn.addEventListener('click', async ()=>{
      if(!files.length) return;
      runBtn.disabled=zipBtn.disabled=allBtn.disabled=true;
      prog.style.width='0%';
      zip=new JSZip(); processed=[];
      const resize=enableResize.checked; const q=parseInt(quality.value)/100;
      const fmt=formatSel.value;

      for(let i=0;i<files.length;i++){
        const f=files[i]; const st=$('status-'+i);
        try{
          st.textContent='Reading...';
          const img=await loadImage(f);
          const c=document.createElement('canvas');const ctx=c.getContext('2d');
          c.width=img.width;c.height=img.height;ctx.drawImage(img,0,0);

          let out=c;
          if(resize){
            const s=fitSize(img.width,img.height,parseInt(maxWidth.value),parseInt(maxHeight.value));
            const cc=document.createElement('canvas');cc.width=s.w;cc.height=s.h;cc.getContext('2d').drawImage(c,0,0,s.w,s.h);
            out=cc;
          }

          const opaque=(fmt==='jpeg')||forceOpaque.checked;
          if(opaque){const solid=document.createElement('canvas');solid.width=out.width;solid.height=out.height;
            const sctx=solid.getContext('2d');sctx.fillStyle=canvasColor.value;sctx.fillRect(0,0,solid.width,solid.height);
            sctx.drawImage(out,0,0);out=solid;}

          const outFmt = fmt==='keep'?f.type.split('/')[1]||'png':fmt;
          st.textContent='Encoding...';
          const blob=await encodeCanvas(out,outFmt,q);
          const url=URL.createObjectURL(blob);
          processed.push({name:f.name.replace(/\.[^.]+$/,'')+'.'+outFmt,blob,url});
          zip.file(f.name.replace(/\.[^.]+$/,'')+'.'+outFmt,blob);
          st.textContent='Done';
        }catch(e){st.textContent='Failed';}
        prog.style.width=((i+1)/files.length*100)+'%';
      }

      runBtn.disabled=false; zipBtn.disabled=false; allBtn.disabled=false;
    });

    zipBtn.addEventListener('click', async ()=>{
      if(!zip)return;
      const blob=await zip.generateAsync({type:'blob'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');a.href=url;a.download='optimized-images.zip';a.click();
      URL.revokeObjectURL(url);
    });

    allBtn.addEventListener('click', ()=>{
      if(!processed.length)return;
      processed.forEach(p=>{
        const a=document.createElement('a');
        a.href=p.url;a.download=p.name;document.body.appendChild(a);
        a.click();a.remove();
      });
    });
  </script>
</body>
</html>