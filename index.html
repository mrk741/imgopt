<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover • Bulk Image Optimizer</title>
  <link rel="icon" href="data:;base64,=" />
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0b0d12">
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    a{color:#4b82ff;text-decoration:none}
    header{padding:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;background:#0f1320;border-bottom:1px solid #1e2332}
    header h1{margin:0;font-size:20px;font-weight:700}
    nav a{margin-left:16px;font-size:14px;color:var(--muted)}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px;margin-top:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    #qualityVal{font-weight:600;margin-left:6px;color:#4b82ff}
    .footer{margin-top:12px;color:#7c8798;font-size:12px;text-align:center}
    .tag{font-size:11px;background:#0d1220;border:1px solid #1d2740;color:#a6b0c0;padding:2px 6px;border-radius:999px}
    .hidden{display:none}
  </style>
</head>
<body>
  <header>
    <h1>Background Remover + Bulk Optimizer</h1>
    <nav>
      <a href="about.html">About</a>
      <a href="help.html">Help</a>
      <button id="installBtn" class="btn" style="margin-left:12px;display:none">Install App</button>
    </nav>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop">
          <p><strong>Drop images here</strong> or click to browse</p>
          <input id="file" type="file" accept="image/*" multiple class="hidden" />
          <p class="muted">PNG, JPG, WebP, AVIF • processed locally</p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <label>Max width (px)
            <input type="number" id="maxWidth" min="64" step="16" value="1600" />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" min="64" step="16" value="1600" />
          </label>
          <label>Output format
            <select id="format">
              <option value="webp">WebP</option>
              <option value="avif">AVIF</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="82" />
            <span id="qualityVal">82%</span>
          </label>
          <label>Background removal
            <select id="bgMode">
              <option value="people" selected>People (on-device)</option>
              <option value="none">Disabled</option>
            </select>
          </label>
          <label>Canvas color (if not transparent)
            <input type="color" id="canvasColor" value="#000000" />
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process Images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <button class="btn" id="clearBtn">Clear Queue</button>
        </div>
        <p class="muted">All work happens in your browser. Nothing is uploaded.</p>

        <div class="footer">
          <span class="tag">MediaPipe</span>
          <span class="tag">Canvas encoders</span>
          <span class="tag">JSZip</span>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar" style="margin:10px 0 14px"><i id="prog"></i></div>
        <div class="thumbs" id="thumbs"></div>
      </div>
    </div>
  </div>

  <!-- Dependencies (UMD, no modules) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

  <script>
    // ---------- Elements ----------
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const clearBtn = $('clearBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const qualityVal = $('qualityVal');
    const bgMode = $('bgMode');
    const canvasColor = $('canvasColor');

    let files = [];
    let zip = null;

    // ---------- Helpers ----------
    quality.addEventListener('input', () => { qualityVal.textContent = quality.value + '%'; });

    function supportsType(mime) {
      try {
        const c = document.createElement('canvas'); c.width = c.height = 2;
        return new Promise((res) => c.toBlob((b) => res(!!b), mime, 0.8));
      } catch { return Promise.resolve(false); }
    }

    function accept(items) {
      const imgs = Array.from(items).filter(f => /^image\//.test(f.type) || /\.(png|jpe?g|webp|avif|heic|heif|gif|bmp)$/i.test(f.name));
      if (!imgs.length) { alert('No images detected.'); return; }
      files = files.concat(imgs);
      countEl.textContent = files.length + ' items';
      runBtn.disabled = files.length === 0;
      renderQueue();
    }

    fileInput.addEventListener('change', (e) => accept(e.target.files));
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
      drop.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); });
    });
    drop.addEventListener('dragenter', () => drop.style.borderColor = '#2b6ef3');
    drop.addEventListener('dragleave', () => drop.style.borderColor = '#33415c');
    drop.addEventListener('drop', (e) => { drop.style.borderColor = '#33415c'; accept(e.dataTransfer.files); });
    drop.addEventListener('click', () => fileInput.click());

    clearBtn.addEventListener('click', () => {
      files = [];
      thumbs.innerHTML = '';
      countEl.textContent = '0 items';
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
    });

    function renderQueue() {
      let html = '';
      for (let i = 0; i < files.length; i++) {
        html += "<div class='thumb'>" +
          "<img id='img-" + i + "' alt='preview' />" +
          "<div class='muted'>" + files[i].name + "</div>" +
          "<div class='muted' id='status-" + i + "'>Queued</div>" +
          "</div>";
      }
      thumbs.innerHTML = html;
      files.forEach((f, i) => {
        const reader = new FileReader();
        reader.onload = () => { const img = $('img-' + i); if (img) img.src = reader.result; };
        reader.readAsDataURL(f);
      });
    }

    // ---------- Background removal (people) ----------
    let selfieSeg = null;
    (async function initSeg() {
      if (window.SelfieSegmentation) {
        selfieSeg = new SelfieSegmentation({ locateFile: (f) => "https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/" + f });
        selfieSeg.setOptions({ modelSelection: 1 });
        if (typeof selfieSeg.initialize === 'function') {
          try { await selfieSeg.initialize(); } catch(e) { console.warn('Segmentation init', e); }
        }
      }
    })();

    function removeBgCanvas(baseCanvas) {
      return new Promise((resolve) => {
        if (!selfieSeg) return resolve(baseCanvas);
        const w = baseCanvas.width, h = baseCanvas.height;
        const img = new Image();
        img.onload = function () {
          selfieSeg.onResults(function(res){
            try {
              const maskC = document.createElement('canvas'); maskC.width = w; maskC.height = h;
              const mc = maskC.getContext('2d');
              mc.drawImage(res.segmentationMask, 0, 0, w, h);
              const mask = mc.getImageData(0,0,w,h);

              const ctx = baseCanvas.getContext('2d');
              const imgData = ctx.getImageData(0,0,w,h);
              const p = imgData.data, m = mask.data; const t = 128;
              for (let i=0;i<p.length;i+=4) { p[i+3] = (m[i] > t) ? 255 : 0; }
              ctx.putImageData(imgData,0,0);
              resolve(baseCanvas);
            } catch (err) {
              console.warn('Matte failed', err);
              resolve(baseCanvas);
            }
          });
          selfieSeg.send({ image: img });
        };
        img.onerror = function(){ resolve(baseCanvas); };
        img.src = baseCanvas.toDataURL('image/png');
      });
    }

    function fitSize(w, h, maxW, maxH) {
      const r = Math.min(maxW / w, maxH / h, 1);
      return { w: Math.max(1, Math.round(w * r)), h: Math.max(1, Math.round(h * r)) };
    }

    function loadImage(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = function(){ URL.revokeObjectURL(url); resolve(img); };
        img.onerror = function(e){ URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    function encodeCanvas(canvas, type, q) {
      var mime = (type === 'jpeg') ? 'image/jpeg' :
                 (type === 'png')  ? 'image/png'  :
                 (type === 'avif') ? 'image/avif' : 'image/webp';
      return new Promise(function(resolve){ canvas.toBlob(function(b){ resolve(b); }, mime, q); });
    }

    document.getElementById('runBtn').addEventListener('click', async function(){
      if (!files.length) return;
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      zip = new JSZip();

      const maxW = parseInt(maxWidth.value, 10);
      const maxH = parseInt(maxHeight.value, 10);
      let outFmt = formatSel.value;
      const q01 = parseInt(quality.value, 10) / 100;
      const doBg = (bgMode.value === 'people');

      // If chosen format unsupported, fall back to PNG
      var mimeWanted = (outFmt==='jpeg')?'image/jpeg':(outFmt==='png')?'image/png':(outFmt==='avif')?'image/avif':'image/webp';
      var supported = await supportsType(mimeWanted);
      if (!supported) outFmt = 'png';

      let done = 0;
      for (let i=0;i<files.length;i++){
        const f = files[i];
        const st = $('status-'+i);
        try {
          st.textContent = 'Reading…';
          const img = await loadImage(f);

          // Work at source resolution for matte, then resize
          const work = document.createElement('canvas');
          work.width = img.naturalWidth || img.width;
          work.height = img.naturalHeight || img.height;
          const wc = work.getContext('2d');
          wc.imageSmoothingQuality = 'high';
          wc.drawImage(img, 0, 0);

          if (doBg) {
            st.textContent = 'Removing background…';
            await removeBgCanvas(work);
          }

          const size = fitSize(work.width, work.height, maxW, maxH);
          const out = document.createElement('canvas');
          out.width = size.w; out.height = size.h;
          const oc = out.getContext('2d');
          oc.imageSmoothingQuality = 'high';

          // Fill if target is opaque (jpeg) or a color requested
          const needsOpaque = (outFmt === 'jpeg');
          if (needsOpaque) {
            oc.fillStyle = canvasColor.value;
            oc.fillRect(0,0,size.w,size.h);
          }

          oc.drawImage(work, 0, 0, size.w, size.h);

          st.textContent = 'Encoding…';
          const blob = await encodeCanvas(out, outFmt, q01);

          // Preserve original name but swap extension only if mime suggests a better one
          let ext = outFmt;
          if (blob && blob.type) {
            if (blob.type.indexOf('jpeg') >= 0) ext = 'jpg';
            else if (blob.type.indexOf('png') >= 0) ext = 'png';
            else if (blob.type.indexOf('webp') >= 0) ext = 'webp';
            else if (blob.type.indexOf('avif') >= 0) ext = 'avif';
          }
          const name = f.name.replace(/\.[^.]+$/, '') + '.' + ext;
          zip.file(name, blob);

          st.textContent = 'Done';
        } catch (e) {
          console.error(e);
          st.textContent = 'Failed';
        } finally {
          done++;
          prog.style.width = ((done/files.length)*100).toFixed(1) + '%';
        }
      }

      zipBtn.disabled = false;
      runBtn.disabled = false;
    });

    document.getElementById('zipBtn').addEventListener('click', async function(){
      if (!zip) return;
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'optimized-images.zip';
      a.click();
      URL.revokeObjectURL(url);
    });

    // ---------- PWA: SW + Install ----------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('/sw.js').catch(console.error);
      });
    }
    (function setupInstall(){
      var deferredPrompt = null;
      var installBtn = document.getElementById('installBtn');
      window.addEventListener('beforeinstallprompt', function(e){
        e.preventDefault();
        deferredPrompt = e;
        if (installBtn) installBtn.style.display = 'inline-block';
      });
      if (installBtn) {
        installBtn.addEventListener('click', async function(){
          if (!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
          deferredPrompt = null;
          installBtn.style.display = 'none';
        });
      }
      window.addEventListener('appinstalled', function(){
        if (installBtn) installBtn.style.display = 'none';
      });
    })();
  </script>
</body>
</html>