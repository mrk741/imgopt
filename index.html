<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bulk Image Resizer & Format Converter</title>
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    header{padding:28px 20px;display:flex;gap:14px;align-items:center;justify-content:center;flex-wrap:wrap}
    header h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.2px}
    .pill{background:#1d2433;border:1px solid #2a3347;padding:6px 10px;border-radius:999px;color:var(--muted);font-size:12px}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted)}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    .footer{margin-top:12px;color:#7c8798;font-size:12px}
    .tag{font-size:11px;background:#0d1220;border:1px solid #1d2740;color:#a6b0c0;padding:2px 6px;border-radius:999px}
    .hidden{display:none}
  </style>
</head>
<body>
  <header>
    <h1>Bulk Image Resizer & Format Converter</h1>
    <span class="pill">Free • Client‑side • No uploads</span>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop">
          <p><strong>Drop images here</strong> or <label class="btn"><input id="file" type="file" accept="image/*" multiple class="hidden"/>Browse</label></p>
          <p class="muted">PNG, JPG, WebP, AVIF, HEIC* • dozens at a time (browser‑dependent)</p>
          <p class="muted">*HEIC/HEIF requires a browser/OS with built‑in support</p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <label>Max width (px)
            <input type="number" id="maxWidth" min="64" step="16" value="1600" />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" min="64" step="16" value="1600" />
          </label>
          <label>Output format
            <select id="format">
              <option value="webp">WebP (small & fast)</option>
              <option value="avif">AVIF (smallest)</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="82" />
          </label>
          <label>Background
            <select id="bg">
              <option value="transparent">Keep transparency</option>
              <option value="white">White</option>
              <option value="black">Black</option>
              <option value="custom">Custom…</option>
            </select>
          </label>
          <label id="customColorWrap" class="hidden">Canvas color
            <input type="color" id="customColor" value="#ffffff" />
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <span class="muted" id="note">All work happens in your browser.</span>
        </div>

        <div class="footer">
          <span class="tag">Canvas encoders</span>
          <span class="tag">JSZip</span>
          <span class="tag">No modules / No wasm</span>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar" style="margin:10px 0 14px"><i id="prog"></i></div>
        <div class="thumbs" id="thumbs"></div>
      </div>
    </div>
  </div>

  <!-- Only dependency: JSZip (UMD) for broad browser support -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    // ===== Elements =====
    const $ = (id)=>document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const bg = $('bg');
    const customColorWrap = $('customColorWrap');
    const customColor = $('customColor');
    const note = $('note');

    let files = [];
    let results = [];
    let zip;

    // ===== Helpers =====
    const ACCEPTED_EXT = ["jpg","jpeg","png","webp","avif","heic","heif","gif","bmp"];
    const isLikelyImage = (file) => {
      if (/^image\//.test(file.type)) return true;
      const ext = (file.name.split('.').pop() || '').toLowerCase();
      return ACCEPTED_EXT.includes(ext);
    };

    function show(el){ el.classList.remove('hidden'); }
    function hide(el){ el.classList.add('hidden'); }

    async function supportsType(mime){
      try{
        const c = document.createElement('canvas');
        c.width=c.height=2;
        return await new Promise((res)=> c.toBlob(b=>res(!!b), mime, 0.8));
      }catch{ return false; }
    }

    (async ()=>{
      const avif = await supportsType('image/avif');
      const webp = await supportsType('image/webp');
      if(!avif){ [...formatSel.options].find(o=>o.value==='avif').text += ' (not supported)'; }
      if(!webp){ [...formatSel.options].find(o=>o.value==='webp').text += ' (not supported)'; }
      if(!webp && !avif){ note.textContent = 'Tip: Chrome/Edge support WebP/AVIF for smaller files.'; }
    })();

    // ===== Drag & Drop + Browse =====
    function accept(items){
      const picked = Array.from(items).filter(isLikelyImage);
      if (!picked.length){ alert('No images detected. Pick PNG/JPG/WebP/AVIF files.'); return; }
      files = [...files, ...picked];
      countEl.textContent = files.length + ' items';
      runBtn.disabled = files.length === 0;
      renderQueue();
    }

    fileInput.addEventListener('change', (e)=>accept(e.target.files));

    // Prevent default to enable drop
    ;['dragenter','dragover','dragleave','drop'].forEach(ev=>{
      drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); });
    });
    drop.addEventListener('dragenter', ()=> drop.style.borderColor='#2b6ef3');
    drop.addEventListener('dragleave', ()=> drop.style.borderColor='#33415c');
    drop.addEventListener('drop', (e)=>{ drop.style.borderColor='#33415c'; accept(e.dataTransfer.files); });
    // Clicking the drop zone opens file picker (for mobile/iOS where DnD isn't supported)
    drop.addEventListener('click', ()=> fileInput.click());

    function renderQueue(){
      thumbs.innerHTML = files.map((f,i)=>`
        <div class="thumb" data-i="${i}">
          <div><img id="img-${i}" alt="preview" /></div>
          <div class="muted">${f.name}</div>
          <div class="muted" id="status-${i}">Queued</div>
        </div>
      `).join('');
      files.forEach((f,i)=>{
        const reader = new FileReader();
        reader.onload = ()=>{ const img = $('img-'+i); if(img) img.src = reader.result; };
        reader.readAsDataURL(f);
      });
    }

    bg.addEventListener('change', ()=>{
      if (bg.value === 'custom') show(customColorWrap); else hide(customColorWrap);
    });

    // ===== Image Pipeline (no modules) =====
    function fitSize(w,h,maxW,maxH){
      const r = Math.min(maxW / w, maxH / h, 1);
      return { w: Math.max(1, Math.round(w*r)), h: Math.max(1, Math.round(h*r)) };
    }

    function loadHTMLImageFromFile(file){
      return new Promise((resolve,reject)=>{
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
        img.onerror = (e)=>{ URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    function canvasEncode(canvas, type, q){
      const mime = (type==='jpeg')?'image/jpeg':(type==='png')?'image/png':(type==='avif')?'image/avif':'image/webp';
      return new Promise((resolve)=> canvas.toBlob(b=>resolve(b), mime, q));
    }

    runBtn.addEventListener('click', async ()=>{
      if(!files.length) return;
      runBtn.disabled = true; zipBtn.disabled = true; results = []; zip = new JSZip();
      prog.style.width = '0%';

      const maxW = +maxWidth.value, maxH = +maxHeight.value;
      let outFmt = formatSel.value;
      const q = +quality.value / 100;

      // Fallback if chosen format isn't supported
      const mimeWanted = (outFmt==='jpeg')?'image/jpeg':(outFmt==='png')?'image/png':(outFmt==='avif')?'image/avif':'image/webp';
      const supported = await (async()=>{
        const c = document.createElement('canvas'); c.width=c.height=2;
        return await new Promise(res=> c.toBlob(b=>res(!!b), mimeWanted, q));
      })();
      if (!supported) outFmt = 'png';

      let done = 0;
      for (const [i,f] of files.entries()){
        const status = $('status-'+i);
        try{
          status.textContent = 'Reading…';
          const img = await loadHTMLImageFromFile(f);

          const { w, h } = fitSize(img.naturalWidth || img.width, img.naturalHeight || img.height, maxW, maxH);
          const canvas = document.createElement('canvas');
          canvas.width = w; canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingQuality = 'high';

          // background fill for JPEG (opaque) or when user requested background
          const needsOpaque = (outFmt==='jpeg' || bg.value!=='transparent');
          if (needsOpaque){
            let color = '#00000000';
            if (bg.value==='white') color = '#ffffff';
            else if (bg.value==='black') color = '#000000';
            else if (bg.value==='custom') color = customColor.value;
            ctx.fillStyle = color; ctx.fillRect(0,0,w,h);
          }

          ctx.drawImage(img, 0, 0, w, h);

          status.textContent = 'Encoding…';
          const blob = await canvasEncode(canvas, outFmt, q);
          const ext = (blob && blob.type.includes('jpeg'))?'jpg':(blob && blob.type.split('/')[1]) || outFmt;
          const name = f.name.replace(/\.[^.]+$/, '') + '.' + ext;
          zip.file(name, blob);

          status.textContent = 'Done';
        }catch(err){ console.error(err); status.textContent = 'Failed'; }
        finally{ done++; prog.style.width = ((done/files.length)*100).toFixed(1)+'%'; }
      }

      zipBtn.disabled = false;
      runBtn.disabled = false;
    });

    zipBtn.addEventListener('click', async ()=>{
      if (!zip) return;
      const blob = await zip.generateAsync({ type:'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'processed-images.zip';
      a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
