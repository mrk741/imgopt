<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Background Remover • Bulk Image Optimizer</title>
  <link rel="icon" href="data:;base64,=" />
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#0b0d12">
  <style>
    :root { --bg:#0b0d12; --card:#131722; --ink:#e8ecf1; --muted:#9aa4b2; }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter;background:var(--bg);color:var(--ink)}
    a{color:#4b82ff;text-decoration:none}
    header{padding:20px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;background:#0f1320;border-bottom:1px solid #1e2332}
    header h1{margin:0;font-size:20px;font-weight:700}
    nav a{margin-left:16px;font-size:14px;color:var(--muted)}
    .btn{background:#2b6ef3;color:#fff;border:0;padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1100px;margin:0 auto;padding:0 18px 60px}
    .card{background:var(--card);border:1px solid #20283a;border-radius:18px;padding:18px;margin-top:18px}
    .grid{display:grid;gap:18px;grid-template-columns:1fr}
    @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
    .drop{border:1.5px dashed #33415c;border-radius:14px;padding:18px;text-align:center;color:var(--muted);cursor:pointer}
    .controls{display:grid;gap:12px;grid-template-columns:repeat(2,1fr)}
    .controls label{display:grid;gap:6px;font-size:12px;color:var(--muted)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .thumbs{display:grid;gap:12px;grid-template-columns:repeat(auto-fill,minmax(150px,1fr))}
    .thumb{background:#0f1320;border:1px solid #20283a;border-radius:12px;padding:10px;display:grid;gap:8px}
    .thumb img{width:100%;height:120px;object-fit:contain;background:#0b0f1a;border-radius:8px}
    .bar{height:6px;background:#111727;border-radius:999px;overflow:hidden}
    .bar>i{display:block;height:100%;width:0%;background:#2b6ef3;transition:width .25s ease}
    .muted{color:var(--muted);font-size:12px}
    select,input[type=number],input[type=range],input[type=color]{background:#0f1320;border:1px solid #20283a;color:var(--ink);border-radius:10px;padding:8px 10px}
    #qualityVal{font-weight:600;margin-left:6px;color:#4b82ff}
    .footer{margin-top:12px;color:#7c8798;font-size:12px;text-align:center}
    .tag{font-size:11px;background:#0d1220;border:1px solid #1d2740;color:#a6b0c0;padding:2px 6px;border-radius:999px}
    .hidden{display:none}
    /* Make the first row span: put the main toggles top-left */
    .controls .fullrow{grid-column:1/-1; display:flex; gap:16px; align-items:center; flex-wrap:wrap}
    .controls .check{display:flex; align-items:center; gap:8px; font-size:13px}
  </style>
</head>
<body>
  <header>
    <h1>Background Remover + Bulk Optimizer</h1>
    <nav>
      <a href="about.html">About</a>
      <a href="help.html">Help</a>
      <button id="installBtn" class="btn" style="margin-left:12px;display:none">Install App</button>
    </nav>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card">
        <div class="drop" id="drop" role="button" tabindex="0" aria-label="Drop images here or press Enter to browse">
          <p><strong>Drop images here</strong> or click to browse</p>
          <input id="file" type="file" accept="image/*" multiple class="hidden" />
          <p class="muted">PNG, JPG, WebP, AVIF, GIF, BMP, HEIC/HEIF, TIFF (where supported) • processed locally</p>
        </div>

        <hr style="border:0;border-top:1px solid #20283a;margin:18px 0" />

        <div class="controls">
          <!-- TOP ROW: checkboxes (positioned first) -->
          <div class="fullrow">
            <label class="check">
              <input type="checkbox" id="enableResize" />
              <span>Enable resizing</span>
            </label>
            <label class="check">
              <input type="checkbox" id="forceOpaque" />
              <span>Force opaque output</span>
            </label>
          </div>

          <!-- Sizing (disabled when resizing is off) -->
          <label>Max width (px)
            <input type="number" id="maxWidth" min="64" step="16" value="1600" disabled />
          </label>
          <label>Max height (px)
            <input type="number" id="maxHeight" min="64" step="16" value="1600" disabled />
          </label>

          <!-- Output -->
          <label>Output format
            <select id="format">
              <option value="keep">Keep original</option>
              <option value="webp" selected>WebP</option>
              <option value="avif">AVIF</option>
              <option value="jpeg">JPEG</option>
              <option value="png">PNG</option>
            </select>
          </label>
          <label>Quality
            <input type="range" id="quality" min="1" max="100" value="70" />
            <span id="qualityVal">70%</span>
          </label>

          <!-- Background removal (disabled by default) -->
          <label>Background removal
            <select id="bgMode">
              <option value="none" selected>Disabled</option>
              <option value="people">People (fast)</option>
              <option value="people_refine">People + refine (best)</option>
            </select>
          </label>
          <label>Matte strength (0–100)
            <input type="range" id="matteStrength" min="0" max="100" value="70" />
          </label>
          <label>Edge feather (px)
            <input type="range" id="edgeFeather" min="0" max="12" value="2" />
          </label>

          <label>Canvas color (for opaque output)
            <input type="color" id="canvasColor" value="#000000" />
          </label>
        </div>

        <div class="row" style="margin-top:12px">
          <button class="btn" id="runBtn" disabled>Process Images</button>
          <button class="btn" id="zipBtn" disabled>Download ZIP</button>
          <button class="btn" id="clearBtn">Clear Queue</button>
        </div>
        <p class="muted">All work happens in your browser. Nothing is uploaded.</p>

        <div class="footer">
          <span class="tag">MediaPipe</span>
          <span class="tag">Canvas encoders</span>
          <span class="tag">JSZip</span>
        </div>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <strong>Queue</strong>
          <span class="muted" id="count">0 items</span>
        </div>
        <div class="bar" style="margin:10px 0 14px"><i id="prog"></i></div>
        <div class="muted" id="sizeTotals">Original: 0 B → Optimized: 0 B</div>
        <div class="thumbs" id="thumbs" style="margin-top:10px"></div>
      </div>
    </div>
  </div>

  <!-- Dependencies (UMD, no modules) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>

  <script>
    // ---------- Elements ----------
    const $ = (id) => document.getElementById(id);
    const fileInput = $('file');
    const drop = $('drop');
    const runBtn = $('runBtn');
    const zipBtn = $('zipBtn');
    const clearBtn = $('clearBtn');
    const thumbs = $('thumbs');
    const prog = $('prog');
    const countEl = $('count');
    const sizeTotals = $('sizeTotals');

    const enableResize = $('enableResize');
    const maxWidth = $('maxWidth');
    const maxHeight = $('maxHeight');
    const formatSel = $('format');
    const quality = $('quality');
    const qualityVal = $('qualityVal');
    const bgMode = $('bgMode');
    const matteStrength = $('matteStrength');
    const edgeFeather = $('edgeFeather');
    const canvasColor = $('canvasColor');
    const forceOpaque = $('forceOpaque');

    let files = [];
    let zip = null;
    let totalOriginal = 0;
    let totalOptimized = 0;

    // ---------- Helpers ----------
    quality.addEventListener('input', () => { qualityVal.textContent = quality.value + '%'; });

    function bytes(n){
      if (n < 1024) return n + ' B';
      if (n < 1024*1024) return (n/1024).toFixed(1) + ' KB';
      if (n < 1024*1024*1024) return (n/1024/1024).toFixed(1) + ' MB';
      return (n/1024/1024/1024).toFixed(2) + ' GB';
    }
    function updateTotals(){
      sizeTotals.textContent = `Original: ${bytes(totalOriginal)} → Optimized: ${bytes(totalOptimized)}${totalOptimized ? ` (${Math.max(0, (1 - totalOptimized/Math.max(1,totalOriginal))*100).toFixed(1)}% smaller)` : ''}`;
    }

    // Checkbox positioning behavior: resizing off by default, inputs disabled
    enableResize.checked = false;
    maxWidth.disabled = true;
    maxHeight.disabled = true;

    enableResize.addEventListener('change', () => {
      const dis = !enableResize.checked;
      maxWidth.disabled = dis;
      maxHeight.disabled = dis;
    });

    function extOK(name) {
      // Common cross-platform extensions (we still verify actual decodability)
      return /\.(png|jpe?g|webp|avif|gif|bmp|heic|heif|tif|tiff|jfif|pjpeg|pjp)$/i.test(name);
    }

    async function canDecode(file) {
      if ('createImageBitmap' in window) {
        try {
          const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
          bmp.close?.();
          return true;
        } catch {}
      }
      try {
        const url = URL.createObjectURL(file);
        await new Promise((res, rej) => {
          const img = new Image();
          img.onload = () => { URL.revokeObjectURL(url); res(); };
          img.onerror = () => { URL.revokeObjectURL(url); rej(); };
          img.src = url;
        });
        return true;
      } catch { return false; }
    }

    function supportsTypeViaCanvas(mime) {
      try {
        const c = document.createElement('canvas'); c.width = c.height = 2;
        return new Promise((res) => c.toBlob((b) => res(!!b), mime, 0.8));
      } catch { return Promise.resolve(false); }
    }
    async function supportsType(mime) {
      if ('ImageDecoder' in window && ImageDecoder.isTypeSupported) {
        try { if (await ImageDecoder.isTypeSupported(mime)) return true; } catch {}
      }
      return supportsTypeViaCanvas(mime);
    }

    function accept(items) {
      const candidates = Array.from(items).filter(f =>
        /^image\//.test(f.type) || extOK(f.name)
      );
      if (!candidates.length) { alert('No images detected.'); return; }

      (async () => {
        const checks = await Promise.all(candidates.map(canDecode));
        const decodables = candidates.filter((_, i) => checks[i]);
        const rejected = candidates.length - decodables.length;
        if (rejected) alert(`${rejected} file(s) skipped (format not supported by this browser).`);

        files = files.concat(decodables);
        totalOriginal += decodables.reduce((sum, f) => sum + (f.size || 0), 0);
        updateTotals();

        countEl.textContent = files.length + ' items';
        runBtn.disabled = files.length === 0;
        renderQueue();
      })();
    }

    fileInput.addEventListener('change', (e) => accept(e.target.files));
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(ev => {
      drop.addEventListener(ev, (e) => { e.preventDefault(); e.stopPropagation(); });
    });
    drop.addEventListener('dragenter', () => drop.style.borderColor = '#2b6ef3');
    drop.addEventListener('dragleave', () => drop.style.borderColor = '#33415c');
    drop.addEventListener('drop', (e) => { drop.style.borderColor = '#33415c'; accept(e.dataTransfer.files); });
    drop.addEventListener('click', () => fileInput.click());
    drop.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') fileInput.click(); });

    clearBtn.addEventListener('click', () => {
      files = [];
      zip = null;
      thumbs.innerHTML = '';
      countEl.textContent = '0 items';
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      totalOriginal = 0;
      totalOptimized = 0;
      updateTotals();
    });

    function renderQueue() {
      let html = '';
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        html += "<div class='thumb'>" +
          "<img id='img-" + i + "' alt='preview' />" +
          "<div class='muted'>" + f.name + " • " + bytes(f.size || 0) + "</div>" +
          "<div class='muted' id='status-" + i + "'>Queued</div>" +
          "</div>";
      }
      thumbs.innerHTML = html;
      files.forEach((f, i) => {
        const reader = new FileReader();
        reader.onload = () => { const img = $('img-' + i); if (img) img.src = reader.result; };
        reader.readAsDataURL(f);
      });
    }

    // ---------- Background removal (improved) ----------
    let selfieSeg = null;
    let selfieResolve = null;

    (async function initSeg() {
      if (window.SelfieSegmentation) {
        selfieSeg = new SelfieSegmentation({ locateFile: (f) => "https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/" + f });
        selfieSeg.setOptions({ modelSelection: 1 });
        try {
          selfieSeg.onResults((res) => { if (selfieResolve) selfieResolve(res); });
          if (typeof selfieSeg.initialize === 'function') await selfieSeg.initialize();
        } catch(e) { console.warn('Segmentation init', e); }
      }
    })();

    async function loadImageToCanvas(file) {
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d', { willReadFrequently: true });
      if ('createImageBitmap' in window) {
        const bmp = await createImageBitmap(file, { imageOrientation: 'from-image' });
        c.width = bmp.width; c.height = bmp.height;
        ctx.drawImage(bmp, 0, 0);
        bmp.close?.();
      } else {
        const url = URL.createObjectURL(file);
        const img = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = (e) => reject(e);
          im.src = url;
        });
        c.width = img.naturalWidth || img.width;
        c.height = img.naturalHeight || img.height;
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);
      }
      return c;
    }

    function fitSize(w, h, maxW, maxH) {
      const r = Math.min(maxW / w, maxH / h, 1);
      return { w: Math.max(1, Math.round(w * r)), h: Math.max(1, Math.round(h * r)) };
    }

    function encodeCanvas(canvas, type, q) {
      const mime = (type === 'jpeg') ? 'image/jpeg' :
                   (type === 'png')  ? 'image/png'  :
                   (type === 'avif') ? 'image/avif' : 'image/webp';
      return new Promise((resolve) => canvas.toBlob((b) => resolve(b), mime, q));
    }

    async function removeBgCanvas(baseCanvas) {
      const mode = bgMode.value;
      if (mode === 'none' || !selfieSeg) return baseCanvas;

      const tempImg = new Image();
      tempImg.src = baseCanvas.toDataURL('image/png');
      await tempImg.decode();
      const segRes = await new Promise((resolve) => { selfieResolve = resolve; selfieSeg.send({ image: tempImg }); });

      const w = baseCanvas.width, h = baseCanvas.height;
      const maskC = document.createElement('canvas'); maskC.width = w; maskC.height = h;
      const mc = maskC.getContext('2d');
      mc.drawImage(segRes.segmentationMask, 0, 0, w, h);

      const featherPx = parseInt(edgeFeather.value, 10) || 0;
      if (featherPx > 0) {
        const blurC = document.createElement('canvas'); blurC.width = w; blurC.height = h;
        const bc = blurC.getContext('2d');
        bc.filter = `blur(${featherPx}px)`;
        bc.drawImage(maskC, 0, 0, w, h);
        mc.clearRect(0,0,w,h);
        mc.drawImage(blurC, 0, 0);
      }

      const mask = mc.getImageData(0,0,w,h);
      const ctx = baseCanvas.getContext('2d');
      const imgData = ctx.getImageData(0,0,w,h);
      const p = imgData.data, m = mask.data;

      const strength = Math.max(0, Math.min(100, parseInt(matteStrength.value, 10) || 0)) / 100; // 0..1
      const baseThresh = 110;
      const hard = (mode === 'people');

      for (let i = 0; i < p.length; i += 4) {
        const v = m[i];
        let alpha;
        if (hard) {
          const t = baseThresh - Math.round(20 * strength);
          alpha = (v > t) ? 255 : 0;
        } else {
          let a = v / 255;
          const gamma = 1 - (0.5 * strength); // 1..0.5
          a = Math.pow(a, gamma);
          const cut = 0.2 - (0.1 * strength); // 0.2..0.1
          a = (a <= cut) ? 0 : (a >= 1 ? 1 : (a - cut) / (1 - cut));
          alpha = Math.round(a * 255);
        }
        p[i + 3] = alpha;
      }
      ctx.putImageData(imgData, 0, 0);
      return baseCanvas;
    }

    function uniqueName(zip, base, ext) {
      let n = base, k = 1;
      while (zip.file(`${n}.${ext}`)) n = `${base} (${k++})`;
      return `${n}.${ext}`;
    }

    // Map input filename extension to encoder-friendly type when "Keep original" selected
    function extToOutFmt(name) {
      const m = name.toLowerCase().match(/\.(\w+)$/);
      if (!m) return 'png';
      const e = m[1];
      if (['jpg','jpeg','jfif','pjpeg','pjp'].includes(e)) return 'jpeg';
      if (['png'].includes(e)) return 'png';
      if (['webp'].includes(e)) return 'webp';
      if (['avif'].includes(e)) return 'avif';
      // For unsupported encoders (gif, bmp, heic, heif, tif, tiff) fall back to PNG
      return 'png';
    }

    document.getElementById('runBtn').addEventListener('click', async function(){
      if (!files.length) return;
      runBtn.disabled = true;
      zipBtn.disabled = true;
      prog.style.width = '0%';
      zip = new JSZip();
      totalOptimized = 0;

      const resizeOn = enableResize.checked;
      const maxW = parseInt(maxWidth.value, 10);
      const maxH = parseInt(maxHeight.value, 10);
      const selectedFmt = formatSel.value;
      const q01 = parseInt(quality.value, 10) / 100;

      let done = 0;
      for (let i = 0; i < files.length; i++) {
        const f = files[i];
        const st = $('status-' + i);
        try {
          st.textContent = 'Decoding…';
          const work = await loadImageToCanvas(f);

          if (bgMode.value !== 'none') {
            st.textContent = 'Removing background…';
            await removeBgCanvas(work);
          }

          let out = work;
          if (resizeOn) {
            const size = fitSize(work.width, work.height, maxW, maxH);
            if (size.w !== work.width || size.h !== work.height) {
              out = document.createElement('canvas');
              out.width = size.w; out.height = size.h;
              const oc = out.getContext('2d');
              oc.imageSmoothingEnabled = true;
              oc.imageSmoothingQuality = 'high';
              oc.drawImage(work, 0, 0, size.w, size.h);
            }
          }

          // Decide output format (handle "keep original")
          let outFmt = selectedFmt === 'keep' ? extToOutFmt(f.name) : selectedFmt;

          // If chosen/suggested format unsupported, fall back to PNG
          const mimeWanted = (outFmt==='jpeg')?'image/jpeg':(outFmt==='png')?'image/png':(outFmt==='avif')?'image/avif':'image/webp';
          const supported = await supportsType(mimeWanted);
          if (!supported) outFmt = 'png';

          // Opaque composite if needed
          const needsOpaque = (outFmt === 'jpeg') || forceOpaque.checked;
          if (needsOpaque) {
            const solid = document.createElement('canvas');
            solid.width = out.width; solid.height = out.height;
            const sc = solid.getContext('2d');
            sc.fillStyle = canvasColor.value;
            sc.fillRect(0, 0, solid.width, solid.height);
            sc.drawImage(out, 0, 0);
            out = solid;
          }

          st.textContent = 'Encoding…';
          const blob = await encodeCanvas(out, outFmt, q01);

          // Extension from resulting blob.type (more robust)
          let ext = outFmt;
          if (blob && blob.type) {
            if (blob.type.includes('jpeg')) ext = 'jpg';
            else if (blob.type.includes('png')) ext = 'png';
            else if (blob.type.includes('webp')) ext = 'webp';
            else if (blob.type.includes('avif')) ext = 'avif';
          }

          const base = f.name.replace(/\.[^.]+$/, '');
          const finalName = uniqueName(zip, base, ext);
          zip.file(finalName, blob);

          totalOptimized += blob.size || 0;
          updateTotals();

          st.textContent = 'Done';
        } catch (e) {
          console.error(e);
          st.textContent = 'Failed';
        } finally {
          done++;
          prog.style.width = ((done / files.length) * 100).toFixed(1) + '%';
          await new Promise(r => setTimeout(r, 0));
        }
      }

      zipBtn.disabled = false;
      runBtn.disabled = false;
    });

    document.getElementById('zipBtn').addEventListener('click', async function(){
      if (!zip) return;
      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'optimized-images.zip';
      a.click();
      URL.revokeObjectURL(url);
    });

    // ---------- PWA: SW + Install ----------
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function(){
        navigator.serviceWorker.register('/sw.js').catch(console.error);
      });
    }
    (function setupInstall(){
      var deferredPrompt = null;
      var installBtn = document.getElementById('installBtn');
      window.addEventListener('beforeinstallprompt', function(e){
        e.preventDefault();
        deferredPrompt = e;
        if (installBtn) installBtn.style.display = 'inline-block';
      });
      if (installBtn) {
        installBtn.addEventListener('click', async function(){
          if (!deferredPrompt) return;
          deferredPrompt.prompt();
          await deferredPrompt.userChoice;
          deferredPrompt = null;
          installBtn.style.display = 'none';
        });
      }
      window.addEventListener('appinstalled', function(){
        if (installBtn) installBtn.style.display = 'none';
      });
    })();
  </script>
</body>
</html>